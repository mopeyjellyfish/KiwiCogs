{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiwi-cogs \u00b6 A simple and easy to use state machine library Github repository : https://github.com/mopeyjellyfish/KiwiCogs/ Documentation https://mopeyjellyfish.github.io/KiwiCogs/ Installation \u00b6 Pip \u00b6 pip install -U kiwi-cogs Poetry \u00b6 poetry add kiwi-cogs Quick start \u00b6 Events \u00b6 Events can be used to transition between states, they can be used to trigger actions or to change the state of the machine. These events can be triggered externally from the machine when something happens. import asyncio from kiwi_cogs import Machine config = { \"name\": \"lights\", # the name of this machine \"initial\": \"green\", # the initial state when the machine is created \"states\": { # the possible states of the machine \"green\": { \"events\": {\"NEXT\": {\"target\": \"yellow\"}}, # when this event is triggered, transition to yellow }, \"yellow\": {\"events\": {\"NEXT\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"NEXT\": {\"target\": \"green\"}}}, }, } async def run(): machine = await Machine.create(config) for _ in range(10): print(f\"Light is: {machine.state.name}\") await machine.event(\"NEXT\") asyncio.run(run()) Transitions \u00b6 Example of how to transition between states based on conditions in the state, here is how to determine if a user is an adult or a child based on their age using some external context which changes independently of the state machine: from kiwi_cogs import Machine async def entered(_): print(\"entered state!\") async def log(_): print(\"LOG!\") def exited(_): print(\"exited!\") def is_adult(context, _): age = context.get(\"age\") return age is not None and age >= 18 def is_child(context, _): age = context.get(\"age\") return age is not None and age < 18 def log_age(context): age = context.get(\"age\") print(f\"User is {age} old!\") def age_determined(context): age = context.get(\"age\") print(f\"Users age has been determined as: {age}\") age_config = { \"name\": \"age\", \"context\": {\"age\": None}, # age unknown \"initial\": \"unknown\", \"states\": { \"unknown\": { \"transitions\": [ {\"target\": \"adult\", \"cond\": is_adult}, {\"target\": \"child\", \"cond\": is_child}, ], \"entry\": [log, entered], \"exit\": age_determined, }, \"adult\": {\"type\": \"final\", \"entry\": log_age}, \"child\": {\"type\": \"final\", \"entry\": log_age}, }, } age_machine await Machine.create(age_config) assert age_machine.state.value == \"unknown\" context = {\"age\": 18} await age_machine.with_context(context=context) assert age_machine.state.value == \"adult\" Hierarchical machine \u00b6 Example of how to create a hierarchical state machine, this is useful for creating a state machine which has multiple sub-machines which can be used to model complex behaviour. Often times there are multiple steps within a given parent state, for example when modelling a crossing for pedestrians. from kiwi_cogs import Machine def is_walking(context, _): return context[\"speed\"] <= 11 def is_running(context, _): return context[\"speed\"] > 11 walk_states = { \"initial\": \"start\", \"states\": { \"start\": { \"transitions\": [ # resolved in order {\"target\": \"walking\", \"cond\": is_walking}, {\"target\": \"running\", \"cond\": is_running}, ], }, \"walking\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"running\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"crossed\": {}, }, } pedestrian_states = { \"initial\": \"walk\", \"states\": { \"walk\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"wait\"}}, **walk_states}, \"wait\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"stop\"}}}, \"stop\": {}, \"blinking\": {}, }, } crossing_config = { \"name\": \"light\", \"initial\": \"green\", \"context\": {\"speed\": 10}, \"states\": { \"green\": {\"events\": {\"TIMER\": {\"target\": \"yellow\"}}}, \"yellow\": {\"events\": {\"TIMER\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"TIMER\": {\"target\": \"green\"}}, **pedestrian_states}, }, \"events\": { \"POWER_OUTAGE\": {\"target\": \".red.blinking\"}, \"POWER_RESTORED\": {\"target\": \".red\"}, }, } Example usage: from kiwi_cogs import Machine crossing = await Machine.create(crossing_config) assert crossing.initial_state.value == \"green\" assert crossing.state.type == \"atomic\" await crossing.event(\"TIMER\") assert crossing.state.value == \"yellow\" assert crossing.state.type == \"atomic\" await crossing.event(\"TIMER\") assert crossing.state.value == {\"red\": {\"walk\": \"walking\"}} await crossing.event(\"CROSSED\") assert crossing.state.value == {\"red\": {\"walk\": \"crossed\"}} assert crossing.state.type == \"compound\" await crossing.event(\"PED_COUNTDOWN\") assert crossing.state.value == {\"red\": \"wait\"} await crossing.event(\"PED_COUNTDOWN\") assert crossing.state.value == {\"red\": \"stop\"} await crossing.event(\"TIMER\") assert crossing.initial_state.value == \"green\" assert crossing.state.type == \"atomic\"","title":"Home"},{"location":"#kiwi-cogs","text":"A simple and easy to use state machine library Github repository : https://github.com/mopeyjellyfish/KiwiCogs/ Documentation https://mopeyjellyfish.github.io/KiwiCogs/","title":"kiwi-cogs"},{"location":"#installation","text":"","title":"Installation"},{"location":"#pip","text":"pip install -U kiwi-cogs","title":"Pip"},{"location":"#poetry","text":"poetry add kiwi-cogs","title":"Poetry"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#events","text":"Events can be used to transition between states, they can be used to trigger actions or to change the state of the machine. These events can be triggered externally from the machine when something happens. import asyncio from kiwi_cogs import Machine config = { \"name\": \"lights\", # the name of this machine \"initial\": \"green\", # the initial state when the machine is created \"states\": { # the possible states of the machine \"green\": { \"events\": {\"NEXT\": {\"target\": \"yellow\"}}, # when this event is triggered, transition to yellow }, \"yellow\": {\"events\": {\"NEXT\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"NEXT\": {\"target\": \"green\"}}}, }, } async def run(): machine = await Machine.create(config) for _ in range(10): print(f\"Light is: {machine.state.name}\") await machine.event(\"NEXT\") asyncio.run(run())","title":"Events"},{"location":"#transitions","text":"Example of how to transition between states based on conditions in the state, here is how to determine if a user is an adult or a child based on their age using some external context which changes independently of the state machine: from kiwi_cogs import Machine async def entered(_): print(\"entered state!\") async def log(_): print(\"LOG!\") def exited(_): print(\"exited!\") def is_adult(context, _): age = context.get(\"age\") return age is not None and age >= 18 def is_child(context, _): age = context.get(\"age\") return age is not None and age < 18 def log_age(context): age = context.get(\"age\") print(f\"User is {age} old!\") def age_determined(context): age = context.get(\"age\") print(f\"Users age has been determined as: {age}\") age_config = { \"name\": \"age\", \"context\": {\"age\": None}, # age unknown \"initial\": \"unknown\", \"states\": { \"unknown\": { \"transitions\": [ {\"target\": \"adult\", \"cond\": is_adult}, {\"target\": \"child\", \"cond\": is_child}, ], \"entry\": [log, entered], \"exit\": age_determined, }, \"adult\": {\"type\": \"final\", \"entry\": log_age}, \"child\": {\"type\": \"final\", \"entry\": log_age}, }, } age_machine await Machine.create(age_config) assert age_machine.state.value == \"unknown\" context = {\"age\": 18} await age_machine.with_context(context=context) assert age_machine.state.value == \"adult\"","title":"Transitions"},{"location":"#hierarchical-machine","text":"Example of how to create a hierarchical state machine, this is useful for creating a state machine which has multiple sub-machines which can be used to model complex behaviour. Often times there are multiple steps within a given parent state, for example when modelling a crossing for pedestrians. from kiwi_cogs import Machine def is_walking(context, _): return context[\"speed\"] <= 11 def is_running(context, _): return context[\"speed\"] > 11 walk_states = { \"initial\": \"start\", \"states\": { \"start\": { \"transitions\": [ # resolved in order {\"target\": \"walking\", \"cond\": is_walking}, {\"target\": \"running\", \"cond\": is_running}, ], }, \"walking\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"running\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"crossed\": {}, }, } pedestrian_states = { \"initial\": \"walk\", \"states\": { \"walk\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"wait\"}}, **walk_states}, \"wait\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"stop\"}}}, \"stop\": {}, \"blinking\": {}, }, } crossing_config = { \"name\": \"light\", \"initial\": \"green\", \"context\": {\"speed\": 10}, \"states\": { \"green\": {\"events\": {\"TIMER\": {\"target\": \"yellow\"}}}, \"yellow\": {\"events\": {\"TIMER\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"TIMER\": {\"target\": \"green\"}}, **pedestrian_states}, }, \"events\": { \"POWER_OUTAGE\": {\"target\": \".red.blinking\"}, \"POWER_RESTORED\": {\"target\": \".red\"}, }, } Example usage: from kiwi_cogs import Machine crossing = await Machine.create(crossing_config) assert crossing.initial_state.value == \"green\" assert crossing.state.type == \"atomic\" await crossing.event(\"TIMER\") assert crossing.state.value == \"yellow\" assert crossing.state.type == \"atomic\" await crossing.event(\"TIMER\") assert crossing.state.value == {\"red\": {\"walk\": \"walking\"}} await crossing.event(\"CROSSED\") assert crossing.state.value == {\"red\": {\"walk\": \"crossed\"}} assert crossing.state.type == \"compound\" await crossing.event(\"PED_COUNTDOWN\") assert crossing.state.value == {\"red\": \"wait\"} await crossing.event(\"PED_COUNTDOWN\") assert crossing.state.value == {\"red\": \"stop\"} await crossing.event(\"TIMER\") assert crossing.initial_state.value == \"green\" assert crossing.state.type == \"atomic\"","title":"Hierarchical machine"},{"location":"modules/","text":"Machine \u00b6 Bases: BaseModel Source code in kiwi_cogs/machine.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class Machine ( BaseModel ): name : str \"\"\"The name for the machine\"\"\" initial : str \"\"\"The name of the initial state\"\"\" state : Optional [ State ] \"\"\"The current state for the machine\"\"\" guards : Optional [ Dict [ str , Callable ]] \"\"\"Possible guards, which are callables\"\"\" actions : Optional [ Dict [ str , Callable ]] \"\"\"Action side effects for the machine\"\"\" context : Optional [ Dict [ str , Any ]] \"\"\"The contextual information \"\"\" events : Optional [ Union [ Dict [ str , Event ], List [ Event ]]] = {} \"\"\"The events at the root of the machine\"\"\" states : Dict [ str , State ] \"\"\"The possible states for the machine\"\"\" logger : Logger = getLogger ( __name__ ) \"\"\"The logger for the machine\"\"\" class Config : arbitrary_types_allowed = True @validator ( \"states\" , pre = True ) def build_states ( cls , value : dict , values : Dict [ str , Any ]) -> Dict [ str , State ]: \"\"\"Builds the states from the passed in states object. :param value: The state configuration dictionary. :type value: dict :return: The built state objects. :rtype: Dict[str, State] \"\"\" guards = values . get ( \"guards\" ) actions = values . get ( \"actions\" ) return { name : State ( name = name , actions = actions , guards = guards , ** val ) for name , val in value . items ()} @root_validator def build_initial_state ( cls , values : Dict [ str , Any ]) -> Dict : \"\"\"Builds the initial state value. :param values: The values passed to the Machine constructor. :type values: Dict :return: The updated values. :rtype: Dict \"\"\" if states := values . get ( \"states\" ): initial = values [ \"initial\" ] values [ \"state\" ] = states . get ( initial ) # check for transient state and transition? return values @classmethod async def create ( cls : \"Machine\" , config : dict ) -> \"Machine\" : # type: ignore[misc] \"\"\"Creates a new instance of the Machine class. :param config: The machine configuration dictionary. :type config: dict :return: The created Machine instance. :rtype: Machine \"\"\" machine = cls ( ** config ) # type: ignore[operator] await machine . step () # make sure all transient states are executed for initial state return machine # type: ignore[no-any-return] @validator ( \"events\" , pre = True ) def build_events ( cls , value : dict ) -> Dict [ str , Event ]: \"\"\"Build the events :param value: The events to be built :type value: dict :returns: The built events as a dictionary :rtype: dict \"\"\" return { name : Event ( name = name , transitions = val ) for name , val in value . items ()} def update_config ( self , config : dict ) -> None : \"\"\"Updates this instances config with the passed in config. :param config: The configuration to update the instance with. :type config: dict \"\"\" return None async def event ( self , event : str ) -> State : \"\"\"Transitions the machine by executing an event :param event: The name of the event to trigger :type event: str :returns: The current state of the machine after the transition :rtype: State \"\"\" self . logger . info ( \"Machine processing event: %s \" , event ) event = self . events . get ( event ) if event in self . events else self . state . get_event ( event ) # type: ignore[union-attr, assignment, operator] if event : transition = await event . get_transition ( self . context , event ) # type: ignore[attr-defined] if transition : # there is a transition if transition . target is not None : await self . do_transition ( target = transition . target ) # if the transition has a target set the state await self . step () # step through the machine as state changed else : self . logger . error ( \"Event %s not found\" , event ) return self . state # type: ignore[return-value] async def step ( self , state : Optional [ State ] = None ) -> State : \"\"\"Step through the machine until no more transitions to move through :param state: The state to start the step process from, defaults to None which will use the current state of the machine :type state: Optional[State], optional :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" if state is None : state = self . state transition = await self . state . get_transition ( context = self . context ) # type: ignore[union-attr , arg-type] if transition and transition . target is not None : await self . do_transition ( transition . target ) return await self . step () # step through the new state return state # type: ignore[return-value] async def on_entry ( self , context : dict ) -> None : \"\"\"Perform any entry actions for the new state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_entry ( context ) # type: ignore[union-attr] async def on_exit ( self , context : dict ) -> None : \"\"\"Perform any exit actions for the current state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_exit ( context ) # type: ignore[union-attr] async def update_state ( self , target : str ) -> bool : \"\"\"Update the current state to the target state :raises: UnknownTarget - If the target state can not be found \"\"\" target_state , remainder = parse_target ( target = target ) state = self . states . get ( target_state ) if state is None : # if the state is target state is None pass to child state to handle if await self . state . update_state ( target , self . context ) is None : # type: ignore[union-attr, arg-type] raise UnknownTarget ( \"Target state can not be found\" ) return False else : if self . state : await self . on_exit ( self . context ) # type: ignore[arg-type] self . state = state if remainder and remainder != target_state : # consume the rest of the path! await self . state . update_state ( remainder , self . context ) # type: ignore[arg-type] return True async def do_transition ( self , target : str ) -> None : \"\"\"Set a state from a target :param target: The name of the state to transition to :type target: str \"\"\" if await self . update_state ( target ): await self . on_entry ( self . context ) # type: ignore[arg-type] return None async def with_context ( self , context : dict ) -> State : \"\"\"Update the context and step through the machine :param context: The context to update the machine with :type context: dict :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" self . context = context # update the context return await self . step () # step through the machine @property def initial_state ( self ) -> State : \"\"\"Get the initial state of the machine :returns: The initial state of the machine :rtype: State \"\"\" return self . states [ self . initial ] actions : Optional [ Dict [ str , Callable ]] instance-attribute \u00b6 Action side effects for the machine context : Optional [ Dict [ str , Any ]] instance-attribute \u00b6 The contextual information events : Optional [ Union [ Dict [ str , Event ], List [ Event ]]] = {} class-attribute instance-attribute \u00b6 The events at the root of the machine guards : Optional [ Dict [ str , Callable ]] instance-attribute \u00b6 Possible guards, which are callables initial : str instance-attribute \u00b6 The name of the initial state initial_state : State property \u00b6 Get the initial state of the machine :returns: The initial state of the machine :rtype: State logger : Logger = getLogger ( __name__ ) class-attribute instance-attribute \u00b6 The logger for the machine name : str instance-attribute \u00b6 The name for the machine state : Optional [ State ] instance-attribute \u00b6 The current state for the machine states : Dict [ str , State ] instance-attribute \u00b6 The possible states for the machine build_events ( value ) \u00b6 Build the events :param value: The events to be built :type value: dict :returns: The built events as a dictionary :rtype: dict Source code in kiwi_cogs/machine.py 79 80 81 82 83 84 85 86 87 88 89 @validator ( \"events\" , pre = True ) def build_events ( cls , value : dict ) -> Dict [ str , Event ]: \"\"\"Build the events :param value: The events to be built :type value: dict :returns: The built events as a dictionary :rtype: dict \"\"\" return { name : Event ( name = name , transitions = val ) for name , val in value . items ()} build_initial_state ( values ) \u00b6 Builds the initial state value. :param values: The values passed to the Machine constructor. :type values: Dict :return: The updated values. :rtype: Dict Source code in kiwi_cogs/machine.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @root_validator def build_initial_state ( cls , values : Dict [ str , Any ]) -> Dict : \"\"\"Builds the initial state value. :param values: The values passed to the Machine constructor. :type values: Dict :return: The updated values. :rtype: Dict \"\"\" if states := values . get ( \"states\" ): initial = values [ \"initial\" ] values [ \"state\" ] = states . get ( initial ) # check for transient state and transition? return values build_states ( value , values ) \u00b6 Builds the states from the passed in states object. :param value: The state configuration dictionary. :type value: dict :return: The built state objects. :rtype: Dict[str, State] Source code in kiwi_cogs/machine.py 35 36 37 38 39 40 41 42 43 44 45 46 47 @validator ( \"states\" , pre = True ) def build_states ( cls , value : dict , values : Dict [ str , Any ]) -> Dict [ str , State ]: \"\"\"Builds the states from the passed in states object. :param value: The state configuration dictionary. :type value: dict :return: The built state objects. :rtype: Dict[str, State] \"\"\" guards = values . get ( \"guards\" ) actions = values . get ( \"actions\" ) return { name : State ( name = name , actions = actions , guards = guards , ** val ) for name , val in value . items ()} create ( config ) async classmethod \u00b6 Creates a new instance of the Machine class. :param config: The machine configuration dictionary. :type config: dict :return: The created Machine instance. :rtype: Machine Source code in kiwi_cogs/machine.py 65 66 67 68 69 70 71 72 73 74 75 76 77 @classmethod async def create ( cls : \"Machine\" , config : dict ) -> \"Machine\" : # type: ignore[misc] \"\"\"Creates a new instance of the Machine class. :param config: The machine configuration dictionary. :type config: dict :return: The created Machine instance. :rtype: Machine \"\"\" machine = cls ( ** config ) # type: ignore[operator] await machine . step () # make sure all transient states are executed for initial state return machine # type: ignore[no-any-return] do_transition ( target ) async \u00b6 Set a state from a target :param target: The name of the state to transition to :type target: str Source code in kiwi_cogs/machine.py 177 178 179 180 181 182 183 184 185 186 async def do_transition ( self , target : str ) -> None : \"\"\"Set a state from a target :param target: The name of the state to transition to :type target: str \"\"\" if await self . update_state ( target ): await self . on_entry ( self . context ) # type: ignore[arg-type] return None event ( event ) async \u00b6 Transitions the machine by executing an event :param event: The name of the event to trigger :type event: str :returns: The current state of the machine after the transition :rtype: State Source code in kiwi_cogs/machine.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 async def event ( self , event : str ) -> State : \"\"\"Transitions the machine by executing an event :param event: The name of the event to trigger :type event: str :returns: The current state of the machine after the transition :rtype: State \"\"\" self . logger . info ( \"Machine processing event: %s \" , event ) event = self . events . get ( event ) if event in self . events else self . state . get_event ( event ) # type: ignore[union-attr, assignment, operator] if event : transition = await event . get_transition ( self . context , event ) # type: ignore[attr-defined] if transition : # there is a transition if transition . target is not None : await self . do_transition ( target = transition . target ) # if the transition has a target set the state await self . step () # step through the machine as state changed else : self . logger . error ( \"Event %s not found\" , event ) return self . state # type: ignore[return-value] on_entry ( context ) async \u00b6 Perform any entry actions for the new state :param context: The context data for the current state :type context: dict Source code in kiwi_cogs/machine.py 140 141 142 143 144 145 146 async def on_entry ( self , context : dict ) -> None : \"\"\"Perform any entry actions for the new state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_entry ( context ) # type: ignore[union-attr] on_exit ( context ) async \u00b6 Perform any exit actions for the current state :param context: The context data for the current state :type context: dict Source code in kiwi_cogs/machine.py 148 149 150 151 152 153 154 async def on_exit ( self , context : dict ) -> None : \"\"\"Perform any exit actions for the current state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_exit ( context ) # type: ignore[union-attr] step ( state = None ) async \u00b6 Step through the machine until no more transitions to move through :param state: The state to start the step process from, defaults to None which will use the current state of the machine :type state: Optional[State], optional :returns: The final state after all possible transitions have been processed :rtype: State Source code in kiwi_cogs/machine.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 async def step ( self , state : Optional [ State ] = None ) -> State : \"\"\"Step through the machine until no more transitions to move through :param state: The state to start the step process from, defaults to None which will use the current state of the machine :type state: Optional[State], optional :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" if state is None : state = self . state transition = await self . state . get_transition ( context = self . context ) # type: ignore[union-attr , arg-type] if transition and transition . target is not None : await self . do_transition ( transition . target ) return await self . step () # step through the new state return state # type: ignore[return-value] update_config ( config ) \u00b6 Updates this instances config with the passed in config. :param config: The configuration to update the instance with. :type config: dict Source code in kiwi_cogs/machine.py 91 92 93 94 95 96 97 def update_config ( self , config : dict ) -> None : \"\"\"Updates this instances config with the passed in config. :param config: The configuration to update the instance with. :type config: dict \"\"\" return None update_state ( target ) async \u00b6 Update the current state to the target state :raises: UnknownTarget - If the target state can not be found Source code in kiwi_cogs/machine.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 async def update_state ( self , target : str ) -> bool : \"\"\"Update the current state to the target state :raises: UnknownTarget - If the target state can not be found \"\"\" target_state , remainder = parse_target ( target = target ) state = self . states . get ( target_state ) if state is None : # if the state is target state is None pass to child state to handle if await self . state . update_state ( target , self . context ) is None : # type: ignore[union-attr, arg-type] raise UnknownTarget ( \"Target state can not be found\" ) return False else : if self . state : await self . on_exit ( self . context ) # type: ignore[arg-type] self . state = state if remainder and remainder != target_state : # consume the rest of the path! await self . state . update_state ( remainder , self . context ) # type: ignore[arg-type] return True with_context ( context ) async \u00b6 Update the context and step through the machine :param context: The context to update the machine with :type context: dict :returns: The final state after all possible transitions have been processed :rtype: State Source code in kiwi_cogs/machine.py 188 189 190 191 192 193 194 195 196 197 198 async def with_context ( self , context : dict ) -> State : \"\"\"Update the context and step through the machine :param context: The context to update the machine with :type context: dict :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" self . context = context # update the context return await self . step () # step through the machine UnknownAction \u00b6 Bases: Exception Action could not be found Source code in kiwi_cogs/exceptions.py 5 6 class UnknownAction ( Exception ): \"\"\"Action could not be found\"\"\" UnknownGuard \u00b6 Bases: Exception Guard could not be found Source code in kiwi_cogs/exceptions.py 9 10 class UnknownGuard ( Exception ): \"\"\"Guard could not be found\"\"\" UnknownTarget \u00b6 Bases: Exception Target state can not be found Source code in kiwi_cogs/exceptions.py 1 2 class UnknownTarget ( Exception ): \"\"\"Target state can not be found\"\"\"","title":"Modules"},{"location":"modules/#kiwi_cogs.Machine","text":"Bases: BaseModel Source code in kiwi_cogs/machine.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class Machine ( BaseModel ): name : str \"\"\"The name for the machine\"\"\" initial : str \"\"\"The name of the initial state\"\"\" state : Optional [ State ] \"\"\"The current state for the machine\"\"\" guards : Optional [ Dict [ str , Callable ]] \"\"\"Possible guards, which are callables\"\"\" actions : Optional [ Dict [ str , Callable ]] \"\"\"Action side effects for the machine\"\"\" context : Optional [ Dict [ str , Any ]] \"\"\"The contextual information \"\"\" events : Optional [ Union [ Dict [ str , Event ], List [ Event ]]] = {} \"\"\"The events at the root of the machine\"\"\" states : Dict [ str , State ] \"\"\"The possible states for the machine\"\"\" logger : Logger = getLogger ( __name__ ) \"\"\"The logger for the machine\"\"\" class Config : arbitrary_types_allowed = True @validator ( \"states\" , pre = True ) def build_states ( cls , value : dict , values : Dict [ str , Any ]) -> Dict [ str , State ]: \"\"\"Builds the states from the passed in states object. :param value: The state configuration dictionary. :type value: dict :return: The built state objects. :rtype: Dict[str, State] \"\"\" guards = values . get ( \"guards\" ) actions = values . get ( \"actions\" ) return { name : State ( name = name , actions = actions , guards = guards , ** val ) for name , val in value . items ()} @root_validator def build_initial_state ( cls , values : Dict [ str , Any ]) -> Dict : \"\"\"Builds the initial state value. :param values: The values passed to the Machine constructor. :type values: Dict :return: The updated values. :rtype: Dict \"\"\" if states := values . get ( \"states\" ): initial = values [ \"initial\" ] values [ \"state\" ] = states . get ( initial ) # check for transient state and transition? return values @classmethod async def create ( cls : \"Machine\" , config : dict ) -> \"Machine\" : # type: ignore[misc] \"\"\"Creates a new instance of the Machine class. :param config: The machine configuration dictionary. :type config: dict :return: The created Machine instance. :rtype: Machine \"\"\" machine = cls ( ** config ) # type: ignore[operator] await machine . step () # make sure all transient states are executed for initial state return machine # type: ignore[no-any-return] @validator ( \"events\" , pre = True ) def build_events ( cls , value : dict ) -> Dict [ str , Event ]: \"\"\"Build the events :param value: The events to be built :type value: dict :returns: The built events as a dictionary :rtype: dict \"\"\" return { name : Event ( name = name , transitions = val ) for name , val in value . items ()} def update_config ( self , config : dict ) -> None : \"\"\"Updates this instances config with the passed in config. :param config: The configuration to update the instance with. :type config: dict \"\"\" return None async def event ( self , event : str ) -> State : \"\"\"Transitions the machine by executing an event :param event: The name of the event to trigger :type event: str :returns: The current state of the machine after the transition :rtype: State \"\"\" self . logger . info ( \"Machine processing event: %s \" , event ) event = self . events . get ( event ) if event in self . events else self . state . get_event ( event ) # type: ignore[union-attr, assignment, operator] if event : transition = await event . get_transition ( self . context , event ) # type: ignore[attr-defined] if transition : # there is a transition if transition . target is not None : await self . do_transition ( target = transition . target ) # if the transition has a target set the state await self . step () # step through the machine as state changed else : self . logger . error ( \"Event %s not found\" , event ) return self . state # type: ignore[return-value] async def step ( self , state : Optional [ State ] = None ) -> State : \"\"\"Step through the machine until no more transitions to move through :param state: The state to start the step process from, defaults to None which will use the current state of the machine :type state: Optional[State], optional :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" if state is None : state = self . state transition = await self . state . get_transition ( context = self . context ) # type: ignore[union-attr , arg-type] if transition and transition . target is not None : await self . do_transition ( transition . target ) return await self . step () # step through the new state return state # type: ignore[return-value] async def on_entry ( self , context : dict ) -> None : \"\"\"Perform any entry actions for the new state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_entry ( context ) # type: ignore[union-attr] async def on_exit ( self , context : dict ) -> None : \"\"\"Perform any exit actions for the current state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_exit ( context ) # type: ignore[union-attr] async def update_state ( self , target : str ) -> bool : \"\"\"Update the current state to the target state :raises: UnknownTarget - If the target state can not be found \"\"\" target_state , remainder = parse_target ( target = target ) state = self . states . get ( target_state ) if state is None : # if the state is target state is None pass to child state to handle if await self . state . update_state ( target , self . context ) is None : # type: ignore[union-attr, arg-type] raise UnknownTarget ( \"Target state can not be found\" ) return False else : if self . state : await self . on_exit ( self . context ) # type: ignore[arg-type] self . state = state if remainder and remainder != target_state : # consume the rest of the path! await self . state . update_state ( remainder , self . context ) # type: ignore[arg-type] return True async def do_transition ( self , target : str ) -> None : \"\"\"Set a state from a target :param target: The name of the state to transition to :type target: str \"\"\" if await self . update_state ( target ): await self . on_entry ( self . context ) # type: ignore[arg-type] return None async def with_context ( self , context : dict ) -> State : \"\"\"Update the context and step through the machine :param context: The context to update the machine with :type context: dict :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" self . context = context # update the context return await self . step () # step through the machine @property def initial_state ( self ) -> State : \"\"\"Get the initial state of the machine :returns: The initial state of the machine :rtype: State \"\"\" return self . states [ self . initial ]","title":"Machine"},{"location":"modules/#kiwi_cogs.machine.Machine.actions","text":"Action side effects for the machine","title":"actions"},{"location":"modules/#kiwi_cogs.machine.Machine.context","text":"The contextual information","title":"context"},{"location":"modules/#kiwi_cogs.machine.Machine.events","text":"The events at the root of the machine","title":"events"},{"location":"modules/#kiwi_cogs.machine.Machine.guards","text":"Possible guards, which are callables","title":"guards"},{"location":"modules/#kiwi_cogs.machine.Machine.initial","text":"The name of the initial state","title":"initial"},{"location":"modules/#kiwi_cogs.machine.Machine.initial_state","text":"Get the initial state of the machine :returns: The initial state of the machine :rtype: State","title":"initial_state"},{"location":"modules/#kiwi_cogs.machine.Machine.logger","text":"The logger for the machine","title":"logger"},{"location":"modules/#kiwi_cogs.machine.Machine.name","text":"The name for the machine","title":"name"},{"location":"modules/#kiwi_cogs.machine.Machine.state","text":"The current state for the machine","title":"state"},{"location":"modules/#kiwi_cogs.machine.Machine.states","text":"The possible states for the machine","title":"states"},{"location":"modules/#kiwi_cogs.machine.Machine.build_events","text":"Build the events :param value: The events to be built :type value: dict :returns: The built events as a dictionary :rtype: dict Source code in kiwi_cogs/machine.py 79 80 81 82 83 84 85 86 87 88 89 @validator ( \"events\" , pre = True ) def build_events ( cls , value : dict ) -> Dict [ str , Event ]: \"\"\"Build the events :param value: The events to be built :type value: dict :returns: The built events as a dictionary :rtype: dict \"\"\" return { name : Event ( name = name , transitions = val ) for name , val in value . items ()}","title":"build_events()"},{"location":"modules/#kiwi_cogs.machine.Machine.build_initial_state","text":"Builds the initial state value. :param values: The values passed to the Machine constructor. :type values: Dict :return: The updated values. :rtype: Dict Source code in kiwi_cogs/machine.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @root_validator def build_initial_state ( cls , values : Dict [ str , Any ]) -> Dict : \"\"\"Builds the initial state value. :param values: The values passed to the Machine constructor. :type values: Dict :return: The updated values. :rtype: Dict \"\"\" if states := values . get ( \"states\" ): initial = values [ \"initial\" ] values [ \"state\" ] = states . get ( initial ) # check for transient state and transition? return values","title":"build_initial_state()"},{"location":"modules/#kiwi_cogs.machine.Machine.build_states","text":"Builds the states from the passed in states object. :param value: The state configuration dictionary. :type value: dict :return: The built state objects. :rtype: Dict[str, State] Source code in kiwi_cogs/machine.py 35 36 37 38 39 40 41 42 43 44 45 46 47 @validator ( \"states\" , pre = True ) def build_states ( cls , value : dict , values : Dict [ str , Any ]) -> Dict [ str , State ]: \"\"\"Builds the states from the passed in states object. :param value: The state configuration dictionary. :type value: dict :return: The built state objects. :rtype: Dict[str, State] \"\"\" guards = values . get ( \"guards\" ) actions = values . get ( \"actions\" ) return { name : State ( name = name , actions = actions , guards = guards , ** val ) for name , val in value . items ()}","title":"build_states()"},{"location":"modules/#kiwi_cogs.machine.Machine.create","text":"Creates a new instance of the Machine class. :param config: The machine configuration dictionary. :type config: dict :return: The created Machine instance. :rtype: Machine Source code in kiwi_cogs/machine.py 65 66 67 68 69 70 71 72 73 74 75 76 77 @classmethod async def create ( cls : \"Machine\" , config : dict ) -> \"Machine\" : # type: ignore[misc] \"\"\"Creates a new instance of the Machine class. :param config: The machine configuration dictionary. :type config: dict :return: The created Machine instance. :rtype: Machine \"\"\" machine = cls ( ** config ) # type: ignore[operator] await machine . step () # make sure all transient states are executed for initial state return machine # type: ignore[no-any-return]","title":"create()"},{"location":"modules/#kiwi_cogs.machine.Machine.do_transition","text":"Set a state from a target :param target: The name of the state to transition to :type target: str Source code in kiwi_cogs/machine.py 177 178 179 180 181 182 183 184 185 186 async def do_transition ( self , target : str ) -> None : \"\"\"Set a state from a target :param target: The name of the state to transition to :type target: str \"\"\" if await self . update_state ( target ): await self . on_entry ( self . context ) # type: ignore[arg-type] return None","title":"do_transition()"},{"location":"modules/#kiwi_cogs.machine.Machine.event","text":"Transitions the machine by executing an event :param event: The name of the event to trigger :type event: str :returns: The current state of the machine after the transition :rtype: State Source code in kiwi_cogs/machine.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 async def event ( self , event : str ) -> State : \"\"\"Transitions the machine by executing an event :param event: The name of the event to trigger :type event: str :returns: The current state of the machine after the transition :rtype: State \"\"\" self . logger . info ( \"Machine processing event: %s \" , event ) event = self . events . get ( event ) if event in self . events else self . state . get_event ( event ) # type: ignore[union-attr, assignment, operator] if event : transition = await event . get_transition ( self . context , event ) # type: ignore[attr-defined] if transition : # there is a transition if transition . target is not None : await self . do_transition ( target = transition . target ) # if the transition has a target set the state await self . step () # step through the machine as state changed else : self . logger . error ( \"Event %s not found\" , event ) return self . state # type: ignore[return-value]","title":"event()"},{"location":"modules/#kiwi_cogs.machine.Machine.on_entry","text":"Perform any entry actions for the new state :param context: The context data for the current state :type context: dict Source code in kiwi_cogs/machine.py 140 141 142 143 144 145 146 async def on_entry ( self , context : dict ) -> None : \"\"\"Perform any entry actions for the new state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_entry ( context ) # type: ignore[union-attr]","title":"on_entry()"},{"location":"modules/#kiwi_cogs.machine.Machine.on_exit","text":"Perform any exit actions for the current state :param context: The context data for the current state :type context: dict Source code in kiwi_cogs/machine.py 148 149 150 151 152 153 154 async def on_exit ( self , context : dict ) -> None : \"\"\"Perform any exit actions for the current state :param context: The context data for the current state :type context: dict \"\"\" await self . state . on_exit ( context ) # type: ignore[union-attr]","title":"on_exit()"},{"location":"modules/#kiwi_cogs.machine.Machine.step","text":"Step through the machine until no more transitions to move through :param state: The state to start the step process from, defaults to None which will use the current state of the machine :type state: Optional[State], optional :returns: The final state after all possible transitions have been processed :rtype: State Source code in kiwi_cogs/machine.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 async def step ( self , state : Optional [ State ] = None ) -> State : \"\"\"Step through the machine until no more transitions to move through :param state: The state to start the step process from, defaults to None which will use the current state of the machine :type state: Optional[State], optional :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" if state is None : state = self . state transition = await self . state . get_transition ( context = self . context ) # type: ignore[union-attr , arg-type] if transition and transition . target is not None : await self . do_transition ( transition . target ) return await self . step () # step through the new state return state # type: ignore[return-value]","title":"step()"},{"location":"modules/#kiwi_cogs.machine.Machine.update_config","text":"Updates this instances config with the passed in config. :param config: The configuration to update the instance with. :type config: dict Source code in kiwi_cogs/machine.py 91 92 93 94 95 96 97 def update_config ( self , config : dict ) -> None : \"\"\"Updates this instances config with the passed in config. :param config: The configuration to update the instance with. :type config: dict \"\"\" return None","title":"update_config()"},{"location":"modules/#kiwi_cogs.machine.Machine.update_state","text":"Update the current state to the target state :raises: UnknownTarget - If the target state can not be found Source code in kiwi_cogs/machine.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 async def update_state ( self , target : str ) -> bool : \"\"\"Update the current state to the target state :raises: UnknownTarget - If the target state can not be found \"\"\" target_state , remainder = parse_target ( target = target ) state = self . states . get ( target_state ) if state is None : # if the state is target state is None pass to child state to handle if await self . state . update_state ( target , self . context ) is None : # type: ignore[union-attr, arg-type] raise UnknownTarget ( \"Target state can not be found\" ) return False else : if self . state : await self . on_exit ( self . context ) # type: ignore[arg-type] self . state = state if remainder and remainder != target_state : # consume the rest of the path! await self . state . update_state ( remainder , self . context ) # type: ignore[arg-type] return True","title":"update_state()"},{"location":"modules/#kiwi_cogs.machine.Machine.with_context","text":"Update the context and step through the machine :param context: The context to update the machine with :type context: dict :returns: The final state after all possible transitions have been processed :rtype: State Source code in kiwi_cogs/machine.py 188 189 190 191 192 193 194 195 196 197 198 async def with_context ( self , context : dict ) -> State : \"\"\"Update the context and step through the machine :param context: The context to update the machine with :type context: dict :returns: The final state after all possible transitions have been processed :rtype: State \"\"\" self . context = context # update the context return await self . step () # step through the machine","title":"with_context()"},{"location":"modules/#kiwi_cogs.UnknownAction","text":"Bases: Exception Action could not be found Source code in kiwi_cogs/exceptions.py 5 6 class UnknownAction ( Exception ): \"\"\"Action could not be found\"\"\"","title":"UnknownAction"},{"location":"modules/#kiwi_cogs.UnknownGuard","text":"Bases: Exception Guard could not be found Source code in kiwi_cogs/exceptions.py 9 10 class UnknownGuard ( Exception ): \"\"\"Guard could not be found\"\"\"","title":"UnknownGuard"},{"location":"modules/#kiwi_cogs.UnknownTarget","text":"Bases: Exception Target state can not be found Source code in kiwi_cogs/exceptions.py 1 2 class UnknownTarget ( Exception ): \"\"\"Target state can not be found\"\"\"","title":"UnknownTarget"},{"location":"examples/hierarchical/","text":"Hierarchical State Machine \u00b6 This example shows how to create a hierarchical state machine. The machine is a traffic light with a pedestrian crossing. The pedestrian crossing has a countdown timer. When the timer reaches zero, the pedestrian crossing changes to red and the traffic light changes to green. import asyncio import random from kiwi_cogs import Machine def is_walking(context, _): return context[\"speed\"] <= 11 def is_running(context, _): return context[\"speed\"] > 11 walk_states = { \"initial\": \"start\", \"states\": { \"start\": { \"transitions\": [ # resolved in order {\"target\": \"walking\", \"cond\": is_walking}, {\"target\": \"running\", \"cond\": is_running}, ], }, \"walking\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"running\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"crossed\": {}, }, } pedestrian_states = { \"initial\": \"walk\", \"states\": { \"walk\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"wait\"}}, **walk_states}, \"wait\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"stop\"}}}, \"stop\": {}, \"blinking\": {}, }, } config = { \"name\": \"light\", \"initial\": \"green\", \"context\": {\"speed\": 10}, \"states\": { \"green\": {\"events\": {\"TIMER\": {\"target\": \"yellow\"}}}, \"yellow\": {\"events\": {\"TIMER\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"TIMER\": {\"target\": \"green\"}}, **pedestrian_states}, }, \"events\": { \"POWER_OUTAGE\": {\"target\": \".red.blinking\"}, \"POWER_RESTORED\": {\"target\": \".red\"}, }, } async def run(): machine = await Machine.create(config) print(f\"Light is: {machine.state.name}\") while True: await machine.event(\"TIMER\") print(f\"Light is: {machine.state.name}\") if machine.state.name == \"red\": value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") await machine.event(\"CROSSED\") value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") await machine.event(\"PED_COUNTDOWN\") value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") await machine.event(\"PED_COUNTDOWN\") value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") # 10 percent chance of power outage if random.random() > 0.9: await machine.event(\"POWER_OUTAGE\") print(f\"Power outage! {machine.state.name}\") print(f\"Battery: {machine.state.value}\") await asyncio.sleep(3) await machine.event(\"POWER_RESTORED\") else: await asyncio.sleep(1) if __name__ == \"__main__\": asyncio.run(run()) Example output: Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop","title":"Hierarchical"},{"location":"examples/hierarchical/#hierarchical-state-machine","text":"This example shows how to create a hierarchical state machine. The machine is a traffic light with a pedestrian crossing. The pedestrian crossing has a countdown timer. When the timer reaches zero, the pedestrian crossing changes to red and the traffic light changes to green. import asyncio import random from kiwi_cogs import Machine def is_walking(context, _): return context[\"speed\"] <= 11 def is_running(context, _): return context[\"speed\"] > 11 walk_states = { \"initial\": \"start\", \"states\": { \"start\": { \"transitions\": [ # resolved in order {\"target\": \"walking\", \"cond\": is_walking}, {\"target\": \"running\", \"cond\": is_running}, ], }, \"walking\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"running\": {\"events\": {\"CROSSED\": {\"target\": \"crossed\"}}}, \"crossed\": {}, }, } pedestrian_states = { \"initial\": \"walk\", \"states\": { \"walk\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"wait\"}}, **walk_states}, \"wait\": {\"events\": {\"PED_COUNTDOWN\": {\"target\": \"stop\"}}}, \"stop\": {}, \"blinking\": {}, }, } config = { \"name\": \"light\", \"initial\": \"green\", \"context\": {\"speed\": 10}, \"states\": { \"green\": {\"events\": {\"TIMER\": {\"target\": \"yellow\"}}}, \"yellow\": {\"events\": {\"TIMER\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"TIMER\": {\"target\": \"green\"}}, **pedestrian_states}, }, \"events\": { \"POWER_OUTAGE\": {\"target\": \".red.blinking\"}, \"POWER_RESTORED\": {\"target\": \".red\"}, }, } async def run(): machine = await Machine.create(config) print(f\"Light is: {machine.state.name}\") while True: await machine.event(\"TIMER\") print(f\"Light is: {machine.state.name}\") if machine.state.name == \"red\": value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") await machine.event(\"CROSSED\") value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") await machine.event(\"PED_COUNTDOWN\") value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") await machine.event(\"PED_COUNTDOWN\") value = machine.state.value[\"red\"] print(f\"Pedestrian: {value}\") # 10 percent chance of power outage if random.random() > 0.9: await machine.event(\"POWER_OUTAGE\") print(f\"Power outage! {machine.state.name}\") print(f\"Battery: {machine.state.value}\") await asyncio.sleep(3) await machine.event(\"POWER_RESTORED\") else: await asyncio.sleep(1) if __name__ == \"__main__\": asyncio.run(run()) Example output: Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop Light is: green Light is: yellow Light is: red Pedestrian: {'walk': 'walking'} Pedestrian: {'walk': 'crossed'} Pedestrian: wait Pedestrian: stop","title":"Hierarchical State Machine"},{"location":"examples/lights/","text":"Light machine \u00b6 This machine is a simple example of a traffic light, it has three states: green, yellow and red. It has a single event: NEXT, which transitions the light to the next state. import asyncio from kiwi_cogs import Machine config = { \"name\": \"lights\", # the name of this machine \"initial\": \"green\", # the initial state when the machine is created \"states\": { # the possible states of the machine \"green\": { \"events\": {\"NEXT\": {\"target\": \"yellow\"}}, # when this event is triggered, transition to yellow }, \"yellow\": {\"events\": {\"NEXT\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"NEXT\": {\"target\": \"green\"}}}, }, } async def run(): machine = await Machine.create(config) for _ in range(10): print(f\"Light is: {machine.state.name}\") await machine.event(\"NEXT\") asyncio.run(run()) Example output: Light is: green Light is: yellow Light is: red Light is: green Light is: yellow Light is: red Light is: green Light is: yellow Light is: red Light is: green","title":"Lights"},{"location":"examples/lights/#light-machine","text":"This machine is a simple example of a traffic light, it has three states: green, yellow and red. It has a single event: NEXT, which transitions the light to the next state. import asyncio from kiwi_cogs import Machine config = { \"name\": \"lights\", # the name of this machine \"initial\": \"green\", # the initial state when the machine is created \"states\": { # the possible states of the machine \"green\": { \"events\": {\"NEXT\": {\"target\": \"yellow\"}}, # when this event is triggered, transition to yellow }, \"yellow\": {\"events\": {\"NEXT\": {\"target\": \"red\"}}}, \"red\": {\"events\": {\"NEXT\": {\"target\": \"green\"}}}, }, } async def run(): machine = await Machine.create(config) for _ in range(10): print(f\"Light is: {machine.state.name}\") await machine.event(\"NEXT\") asyncio.run(run()) Example output: Light is: green Light is: yellow Light is: red Light is: green Light is: yellow Light is: red Light is: green Light is: yellow Light is: red Light is: green","title":"Light machine"},{"location":"examples/tennis/","text":"Tennis Game \u00b6 Description \u00b6 This is a simple tennis game. The game is played by two players. Each player has a score of 0 at the beginning of the game. The first player to score 4 points wins the game. States \u00b6 serving : Normal play deuce : When both players have a score of 3 advantage : When one player has a score of 4 and the other has a score of 3 import asyncio import curses import random from kiwi_cogs import Machine, StateType def check_if_score_is_deuce(context, _): \"\"\"Checks if the score is deuce in a tennis game :param context: The current context of the game, including the scores of both players :type context: dict :returns: True if the score is deuce, False otherwise :rtype: bool \"\"\" return context[\"player1_score\"] >= 3 and context[\"player2_score\"] == context[\"player1_score\"] def check_if_score_is_advantage(context, _): \"\"\"Checks if the score is advantage for one of the players in a tennis game :param context: The current context of the game, including the scores of both players :type context: dict :returns: True if the score is advantage for one player, False otherwise :rtype: bool \"\"\" if context[\"player1_score\"] > context[\"player2_score\"]: return context[\"player1_score\"] >= 4 and context[\"player1_score\"] - context[\"player2_score\"] == 1 else: return context[\"player2_score\"] >= 4 and context[\"player2_score\"] - context[\"player1_score\"] == 1 def check_if_score_is_game(context, _): \"\"\"Checks if the score is a game for one of the players in a tennis game :param context: The current context of the game, including the scores of both players :type context: dict :returns: True if the score is a game for one player, False otherwise :rtype: bool \"\"\" if context[\"player1_score\"] > context[\"player2_score\"]: return context[\"player1_score\"] >= 4 and context[\"player1_score\"] - context[\"player2_score\"] >= 2 else: return context[\"player2_score\"] >= 4 and context[\"player2_score\"] - context[\"player1_score\"] >= 2 def increment_player1_score(context, _): context[\"player1_score\"] += 1 def increment_player2_score(context, _): context[\"player2_score\"] += 1 config = { \"name\": \"tennis_game\", \"initial\": \"serving\", \"context\": {\"player1_score\": 0, \"player2_score\": 0}, \"states\": { \"serving\": { \"transitions\": [ {\"target\": \"deuce\", \"cond\": \"isDeuce\"}, # use a named guard for transitions {\"target\": \"advantage\", \"cond\": \"isAdvantage\"}, {\"target\": \"game\", \"cond\": \"isGame\"}, ], \"events\": { \"PLAYER1_SCORES\": {\"actions\": \"incPlayer1Score\"}, # use a named action for events \"PLAYER2_SCORES\": {\"actions\": \"incPlayer2Score\"}, }, }, \"deuce\": { \"transitions\": [ {\"target\": \"advantage\", \"cond\": \"isAdvantage\"}, {\"target\": \"game\", \"cond\": \"isGame\"}, ], \"events\": { \"PLAYER1_SCORES\": {\"actions\": increment_player1_score}, # use a function for events as well! \"PLAYER2_SCORES\": {\"actions\": increment_player2_score}, }, }, \"advantage\": { \"transitions\": [ {\"target\": \"deuce\", \"cond\": check_if_score_is_deuce}, # Functions can be used as well {\"target\": \"game\", \"cond\": check_if_score_is_game}, ], \"events\": { \"PLAYER1_SCORES\": {\"actions\": increment_player1_score}, \"PLAYER2_SCORES\": {\"actions\": increment_player2_score}, }, }, \"game\": { \"transitions\": [ { \"target\": \"player1_wins\", \"cond\": lambda context, _: context[\"player1_score\"] > context[\"player2_score\"], }, # any callable can be used as a condition { \"target\": \"player2_wins\", \"cond\": lambda context, _: context[\"player2_score\"] > context[\"player1_score\"], }, ], }, \"player1_wins\": {\"type\": \"final\"}, # final states are used to indicate that the machine is finished \"player2_wins\": {\"type\": \"final\"}, }, \"guards\": { # Register the guards, reusable conditions that can be used in transitions \"isDeuce\": check_if_score_is_deuce, \"isAdvantage\": check_if_score_is_advantage, \"isGame\": check_if_score_is_game, }, \"actions\": { \"incPlayer1Score\": increment_player1_score, \"incPlayer2Score\": increment_player2_score, }, } async def get_machine(): return await Machine.create(config) def print_score(stdscr, state, score1, score2): stdscr.clear() # Create a new window for the scores, with a border score_window = curses.newwin(5, 30, 3, 0) score_window.box() # Print scores score_window.addstr(1, 1, f\"State: {state}\") score_window.addstr(2, 1, f\"Player 1: {score1}\") score_window.addstr(3, 1, f\"Player 2: {score2}\") score_window.refresh() async def tennis_game(stdscr): machine = await get_machine() events = (\"PLAYER1_SCORES\", \"PLAYER2_SCORES\") while machine.state.type != StateType.final: score_1 = machine.context[\"player1_score\"] score_2 = machine.context[\"player2_score\"] state = machine.state.value print_score(stdscr, state, score_1, score_2) event = random.choice(events) # randomly select a player to score await asyncio.sleep(0.2) await machine.event(event) score_1 = machine.context[\"player1_score\"] score_2 = machine.context[\"player2_score\"] state = machine.state.value print_score(stdscr, state, score_1, score_2) await asyncio.sleep(3) def run(stdscr): asyncio.run(tennis_game(stdscr)) if __name__ == \"__main__\": # Initialize curses curses.wrapper(run) Example output: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502State: player2_wins \u2502 \u2502Player 1: 3 \u2502 \u2502Player 2: 5 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Tennis"},{"location":"examples/tennis/#tennis-game","text":"","title":"Tennis Game"},{"location":"examples/tennis/#description","text":"This is a simple tennis game. The game is played by two players. Each player has a score of 0 at the beginning of the game. The first player to score 4 points wins the game.","title":"Description"},{"location":"examples/tennis/#states","text":"serving : Normal play deuce : When both players have a score of 3 advantage : When one player has a score of 4 and the other has a score of 3 import asyncio import curses import random from kiwi_cogs import Machine, StateType def check_if_score_is_deuce(context, _): \"\"\"Checks if the score is deuce in a tennis game :param context: The current context of the game, including the scores of both players :type context: dict :returns: True if the score is deuce, False otherwise :rtype: bool \"\"\" return context[\"player1_score\"] >= 3 and context[\"player2_score\"] == context[\"player1_score\"] def check_if_score_is_advantage(context, _): \"\"\"Checks if the score is advantage for one of the players in a tennis game :param context: The current context of the game, including the scores of both players :type context: dict :returns: True if the score is advantage for one player, False otherwise :rtype: bool \"\"\" if context[\"player1_score\"] > context[\"player2_score\"]: return context[\"player1_score\"] >= 4 and context[\"player1_score\"] - context[\"player2_score\"] == 1 else: return context[\"player2_score\"] >= 4 and context[\"player2_score\"] - context[\"player1_score\"] == 1 def check_if_score_is_game(context, _): \"\"\"Checks if the score is a game for one of the players in a tennis game :param context: The current context of the game, including the scores of both players :type context: dict :returns: True if the score is a game for one player, False otherwise :rtype: bool \"\"\" if context[\"player1_score\"] > context[\"player2_score\"]: return context[\"player1_score\"] >= 4 and context[\"player1_score\"] - context[\"player2_score\"] >= 2 else: return context[\"player2_score\"] >= 4 and context[\"player2_score\"] - context[\"player1_score\"] >= 2 def increment_player1_score(context, _): context[\"player1_score\"] += 1 def increment_player2_score(context, _): context[\"player2_score\"] += 1 config = { \"name\": \"tennis_game\", \"initial\": \"serving\", \"context\": {\"player1_score\": 0, \"player2_score\": 0}, \"states\": { \"serving\": { \"transitions\": [ {\"target\": \"deuce\", \"cond\": \"isDeuce\"}, # use a named guard for transitions {\"target\": \"advantage\", \"cond\": \"isAdvantage\"}, {\"target\": \"game\", \"cond\": \"isGame\"}, ], \"events\": { \"PLAYER1_SCORES\": {\"actions\": \"incPlayer1Score\"}, # use a named action for events \"PLAYER2_SCORES\": {\"actions\": \"incPlayer2Score\"}, }, }, \"deuce\": { \"transitions\": [ {\"target\": \"advantage\", \"cond\": \"isAdvantage\"}, {\"target\": \"game\", \"cond\": \"isGame\"}, ], \"events\": { \"PLAYER1_SCORES\": {\"actions\": increment_player1_score}, # use a function for events as well! \"PLAYER2_SCORES\": {\"actions\": increment_player2_score}, }, }, \"advantage\": { \"transitions\": [ {\"target\": \"deuce\", \"cond\": check_if_score_is_deuce}, # Functions can be used as well {\"target\": \"game\", \"cond\": check_if_score_is_game}, ], \"events\": { \"PLAYER1_SCORES\": {\"actions\": increment_player1_score}, \"PLAYER2_SCORES\": {\"actions\": increment_player2_score}, }, }, \"game\": { \"transitions\": [ { \"target\": \"player1_wins\", \"cond\": lambda context, _: context[\"player1_score\"] > context[\"player2_score\"], }, # any callable can be used as a condition { \"target\": \"player2_wins\", \"cond\": lambda context, _: context[\"player2_score\"] > context[\"player1_score\"], }, ], }, \"player1_wins\": {\"type\": \"final\"}, # final states are used to indicate that the machine is finished \"player2_wins\": {\"type\": \"final\"}, }, \"guards\": { # Register the guards, reusable conditions that can be used in transitions \"isDeuce\": check_if_score_is_deuce, \"isAdvantage\": check_if_score_is_advantage, \"isGame\": check_if_score_is_game, }, \"actions\": { \"incPlayer1Score\": increment_player1_score, \"incPlayer2Score\": increment_player2_score, }, } async def get_machine(): return await Machine.create(config) def print_score(stdscr, state, score1, score2): stdscr.clear() # Create a new window for the scores, with a border score_window = curses.newwin(5, 30, 3, 0) score_window.box() # Print scores score_window.addstr(1, 1, f\"State: {state}\") score_window.addstr(2, 1, f\"Player 1: {score1}\") score_window.addstr(3, 1, f\"Player 2: {score2}\") score_window.refresh() async def tennis_game(stdscr): machine = await get_machine() events = (\"PLAYER1_SCORES\", \"PLAYER2_SCORES\") while machine.state.type != StateType.final: score_1 = machine.context[\"player1_score\"] score_2 = machine.context[\"player2_score\"] state = machine.state.value print_score(stdscr, state, score_1, score_2) event = random.choice(events) # randomly select a player to score await asyncio.sleep(0.2) await machine.event(event) score_1 = machine.context[\"player1_score\"] score_2 = machine.context[\"player2_score\"] state = machine.state.value print_score(stdscr, state, score_1, score_2) await asyncio.sleep(3) def run(stdscr): asyncio.run(tennis_game(stdscr)) if __name__ == \"__main__\": # Initialize curses curses.wrapper(run) Example output: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502State: player2_wins \u2502 \u2502Player 1: 3 \u2502 \u2502Player 2: 5 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"States"}]}